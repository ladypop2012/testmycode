
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, CallbackContext
from telegram import InputFile
import requests
import time
from telegram.ext import Updater, CommandHandler, CallbackContext
from myconfig import TELEGRAM_BOT_TOKEN, STORE_ID,BTCPAY_API_KEY,BTCPAY_URL


#Version 2: Print Logs Clean - Uses Rounded Pricing No Decimals - Images Folder - Uses Safe Api File Calls - Checks Paid Invoices - Passes Cart Metadata-


# Set environment variables
logging.basicConfig(level=logging.INFO)



# Define the product catalog
PRODUCTS = {
    1: {"name": "Popcorn Life", "price": (3), "image": "images/taco1.jpg", "category": "Category A"},
    2: {"name": "Tacos n Fish", "price": (5), "image": "images/taco2.jpg", "category": "Category B"},
    3: {"name": "Pickles & Cheese", "price": (12), "image": "images/taco3.jpg", "category": "Category B"},
    4: {"name": "Burgers Delight", "price": (8), "image": "images/taco1.jpg", "category": "Category A"},
    5: {"name": "Fancy Sushi", "price": (20), "image": "images/taco2.jpg", "category": "Category C"},
    # ...
}

CATEGORIES = {
    "Category A": [1, 4],  # Adding product ID 4 to Category A
    "Category B": [2, 3],  # Category B remains the same
    "Category C": [5],     # Adding product ID 5 to Category C
    # ...
}



# Initialize an empty cart
cart = {}

def start(update: Update, context: CallbackContext):
    keyboard = [
        [InlineKeyboardButton("View Products", callback_data="view_products")]
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text("Welcome to My Store! Choose an option:", reply_markup=reply_markup)

def view_products(update: Update, context: CallbackContext):
    keyboard = [
        [InlineKeyboardButton(category, callback_data=f"category_{category}")] for category in CATEGORIES
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.message.reply_text("Please choose a category:", reply_markup=reply_markup)


def view_category(update: Update, context: CallbackContext):
    query = update.callback_query
    category = query.data.split("_")[1]

    product_ids = CATEGORIES[category]

    for product_id in product_ids:
        product = PRODUCTS[product_id]
        product_info = f"{product['name']}\nPrice: {product['price']} USD"

        # Send the product image with the caption
        with open(product["image"], "rb") as image_file:
            add_to_cart_button = InlineKeyboardButton(f"Add {product['name']} to Cart", callback_data=f"add_{product_id}")
            keyboard = InlineKeyboardMarkup.from_button(add_to_cart_button)

            context.bot.send_photo(chat_id=query.message.chat_id, photo=InputFile(image_file), caption=product_info, reply_markup=keyboard)
    
    # Add navigation buttons
    keyboard = [
        [InlineKeyboardButton("Back to Categories", callback_data="view_products")],
        [InlineKeyboardButton("View Cart", callback_data="view_cart")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    query.message.reply_text("What would you like to do next?", reply_markup=reply_markup)




def add_to_cart(update: Update, context: CallbackContext):
    user_id = update.callback_query.from_user.id
    product_id = int(update.callback_query.data.split("_")[1])

    if user_id not in cart:
        cart[user_id] = {}

    if product_id in cart[user_id]:
        cart[user_id][product_id]["quantity"] += 1
    else:
        product = PRODUCTS[product_id]
        cart[user_id][product_id] = {"name": product["name"], "price": product["price"], "quantity": 1}

    update.callback_query.answer(text=f"{PRODUCTS[product_id]['name']} added to your cart.")





def remove_from_cart(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id

    if user_id not in cart or not cart[user_id]:
        query.answer("Your cart is empty.")
        return

    # Extract the product ID from the command
    product_id = int(context.args[0])

    if product_id not in cart[user_id]:
        query.answer("This product is not in your cart.")
        return

    # Decrease the product quantity by 1
    cart[user_id][product_id]['quantity'] -= 1

    # Remove the product from the cart if its quantity is 0
    if cart[user_id][product_id]['quantity'] == 0:
        del cart[user_id][product_id]

    query.answer("Product removed from the cart.")


# VIEW CART HAS ALOT OF CUSTOM CODE - IF YOU EDIT WATCH THE DEF AREAS

def view_cart(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id

    if user_id not in cart or not cart[user_id]:
        query.answer("Your cart is empty.")
        return

    cart_text = "Your cart:\n\n"
    total = 0

    keyboard = []

    for product_id, item in cart[user_id].items():
        product = PRODUCTS[product_id]
        quantity = item['quantity']
        price = product['price'] * quantity
        cart_text += f"{product['name']} (qty x {quantity}) = ${price}\n"
        total += price

        # Add an "Edit Quantity" button for each product
        keyboard.append([
            InlineKeyboardButton(f"{product['name']} (x{quantity}) - Edit Quantity", callback_data=f"edit_quantity_{product_id}")
        ])

    cart_text += f"\nTotal: ${total}"

    query.answer()

    # Add the "Checkout" and "Add More Items" buttons after listing the products
    keyboard.append([InlineKeyboardButton("Checkout", callback_data="checkout")])
    keyboard.append([InlineKeyboardButton("Add More Items", callback_data="view_products")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    # Call the send_cart function instead of sending a message directly
    send_cart(update, context)
 
 
 #Handles sending a message only when view cart button is pressed othewise its slient cart updates
def view_cart_button_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    view_cart(update, context, from_view_cart_button=True)

def send_cart(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id

    if user_id not in cart or not cart[user_id]:
        query.answer("Your cart is empty.")
        return

    
    cart_text = "Your cart:\n\n"
    total = 0

    keyboard = []

    for product_id, item in cart[user_id].items():
        product = PRODUCTS[product_id]
        quantity = item['quantity']
        price = product['price'] * quantity
        cart_text += f"{product['name']} (qty x {quantity}) = ${price}\n"
        total += price

        # Add an "Edit Quantity" button for each product
        keyboard.append([
            InlineKeyboardButton(f"{product['name']} (x{quantity}) - Edit Quantity", callback_data=f"edit_quantity_{product_id}")
        ])

    cart_text += f"\nTotal: ${total}"

    query.answer()

    
    # Add the "Checkout" and "Add More Items" buttons after listing the products
    keyboard.append([InlineKeyboardButton("Checkout", callback_data="checkout")])
    keyboard.append([InlineKeyboardButton("Add More Items", callback_data="view_products")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    context.bot.send_message(chat_id=user_id, text=cart_text, reply_markup=reply_markup)



def edit_quantity(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id
    product_id = int(query.data.split('_')[2])

    if user_id not in cart or product_id not in cart[user_id]:
        query.answer("This product is not in your cart.")
        return

    keyboard = [
        [InlineKeyboardButton(str(i), callback_data=f"set_quantity_{product_id}_{i}") for i in range(1, 11)]
    ]

    keyboard.append([InlineKeyboardButton("Cancel", callback_data="view_cart")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    query.answer()
    query.edit_message_text(f"Select the desired quantity for {PRODUCTS[product_id]['name']}:", reply_markup=reply_markup)


def set_quantity(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id
    product_id, new_quantity = map(int, query.data.split('_')[2:])

    if user_id not in cart or product_id not in cart[user_id]:
        query.answer("This product is not in your cart.")
        return

    cart[user_id][product_id]['quantity'] = new_quantity
    query.answer(f"Quantity updated for {PRODUCTS[product_id]['name']}.")
    view_cart(update, context)




def increase_product_quantity(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id
    product_id = int(query.data.split('_')[1])

    if user_id in cart and product_id in cart[user_id]:
        cart[user_id][product_id]['quantity'] += 1
        
    query.answer()
    view_cart(update, context)


def decrease_product_quantity(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = query.from_user.id
    product_id = int(query.data.split('_')[1])

    if user_id in cart and product_id in cart[user_id]:
        if cart[user_id][product_id]['quantity'] > 1:
            cart[user_id][product_id]['quantity'] -= 1
        
        else:
            del cart[user_id][product_id]

    query.answer()
    view_cart(update, context)




def pre_checkout(update: Update, context: CallbackContext):
    update.callback_query.answer()  # Answer the callback query first
    update.callback_query.edit_message_text('You should only click ðŸ’µ "READY TO PAY" if you have funds ready to pay at this moment. Invoices & Bitcoin Payment Addresses expire after 2 hours.', reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ðŸ’µ READY TO PAY", callback_data='ready_to_pay')]]))


def create_invoice(total, username, chat_id):
    data = {
        "metadata": {
            "telegram_username": username,
            "telegram_chat_id": chat_id,
            "cart": cart

        },
        "checkout": {
            "speedPolicy": "MediumSpeed",
            "paymentMethods": [
                "BTC"  # You can add more payment methods if necessary
            ],
            "defaultPaymentMethod": "BTC",
            "expirationMinutes": 120,
            "monitoringMinutes": 120,
            "paymentTolerance": 0,
            "redirectURL": "string",
            "redirectAutomatically": False,
            "requiresRefundEmail": False,
            "checkoutType": None,

        },
        "receipt": {
            "enabled": True,
            "showQR": None,
            "showPayments": None
        },
        "amount": str(total),
        "currency": "USD"
    }
    headers = {
        "Authorization": f"token {BTCPAY_API_KEY}",
        "Content-Type": "application/json"
    }
    response = requests.post(BTCPAY_URL + f'/api/v1/stores/{STORE_ID}/invoices', json=data, headers=headers)
    return response



def pay_now(update, context):
    chat_id = update.effective_chat.id
    user_id = update.message.from_user.id
    username = update.message.from_user.username

    # Calculate the total amount for the cart
    total = 0
    for product_id, item in cart[user_id].items():
        product = PRODUCTS[product_id]
        quantity = item['quantity']
        price = product['price'] * quantity
        total += price

    context.bot.send_message(chat_id=chat_id, text="â³ Please wait while we create your payment instructions...")
    time.sleep(3)  # Add a 3-second delay

    # Call the create_invoice function and get the response object
    response = create_invoice(total, username, chat_id)



    # Parse response as JSON
    invoice = response.json()

    # Get invoice ID from checkout link
    invoice_id = invoice['checkoutLink'].split('/')[-1]

    # Get Bitcoin address
    btc_address = 'N/A'
    headers = {
        "Authorization": f"token {BTCPAY_API_KEY}"
    }
    payment_methods_response = requests.get(BTCPAY_URL + f'/api/v1/stores/{STORE_ID}/invoices/{invoice_id}/payment-methods', headers=headers)
    payment_methods = payment_methods_response.json()
    for payment_method in payment_methods:
        if payment_method['cryptoCode'] == 'BTC':
            btc_address = payment_method['destination']

    # Get invoice URL
    invoice_url = invoice.get('checkoutLink', 'N/A')

    # Send invoice and BTC address messages
    context.bot.send_message(chat_id=chat_id, text=f"Your payment invoice has been created. Invoices & Bitcoin Address Expire in 2 Hours...\n\n ðŸ‘‰ Pay â‚¿itcoin Using Invoice URL: {invoice_url}\n\n or \n\n ðŸ‘‰ Send ${total} USD \n To This â‚¿itcoin Address:")
    context.bot.send_message(chat_id=chat_id, text=f"{btc_address}")

# Check payment status every 2 minutes
    context.job_queue.run_repeating(check_invoice_status, interval=120, first=120, context={"invoice_id": invoice_id, "chat_id": chat_id})

def ready_to_pay(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    query.edit_message_text(text="âœ… JUST CONFIRMIRING .... \n tap here ðŸ‘‰/paynow to confirm you're ready to pay. ")

def checkout(update: Update, context: CallbackContext):
    pre_checkout(update, context)

# Check Every 2 Minutes If Invoice is Paid/Settled >>start>>

def check_invoice_status(context: CallbackContext):
    job = context.job
    invoice_id = context.job.context["invoice_id"]
    chat_id = context.job.context["chat_id"]
    headers = {
        "Authorization": f"token {BTCPAY_API_KEY}"
    }
    # Get invoice status

    response = requests.get(f'{BTCPAY_URL}/api/v1/stores/{STORE_ID}/invoices/{invoice_id}', headers=headers)
    invoice_status = response.json().get('status', '')


    response_data = response.json()
    


    if invoice_status == "Settled":
        context.bot.send_message(chat_id=chat_id, text="âœ… Your payment has been completed successfully. The store admin @SweetEarlJones has been notified and will contact you by PM to get your shipping address and answer any questions you may have.")
        context.job.schedule_removal()
    else:
        remaining_checks = context.job.context["remaining_checks"] - 1
        if remaining_checks <= 0:
            context.job.schedule_removal()
        else:
            context.job.context["remaining_checks"] = remaining_checks

def start_checking_invoice_status(update: Update, context: CallbackContext, invoice_id: str):
    chat_id = update.effective_chat.id
    context.job_queue.run_repeating(
        check_invoice_status,
        interval=120,
        first=120,
        context={"invoice_id": invoice_id, "chat_id": chat_id, "remaining_checks": 55}
    )

# Check Every 2 Minutes If Invoice is Paid/Settled  >>END>>


def main():
    updater = Updater(TELEGRAM_BOT_TOKEN, use_context=True)
    print("Starting the bot...")

    dispatcher = updater.dispatcher
    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CallbackQueryHandler(view_products, pattern="^view_products$"))
    dispatcher.add_handler(CallbackQueryHandler(add_to_cart, pattern="^add_\d+$"))
    dispatcher.add_handler(CallbackQueryHandler(view_cart, pattern="^view_cart$"))
    dispatcher.add_handler(CallbackQueryHandler(pre_checkout, pattern="^checkout$"))
    dispatcher.add_handler(CallbackQueryHandler(view_category, pattern="^category_.+$"))
    dispatcher.add_handler(CommandHandler("remove", remove_from_cart, pass_args=True))
    dispatcher.add_handler(CallbackQueryHandler(edit_quantity, pattern='^edit_quantity_\\d+$'))
    dispatcher.add_handler(CallbackQueryHandler(set_quantity, pattern='^set_quantity_\\d+_\\d+$'))
    dispatcher.add_handler(CallbackQueryHandler(view_cart_button_handler, pattern='^view_cart$'))
    dispatcher.add_handler(CommandHandler("paynow", pay_now))
    dispatcher.add_handler(CallbackQueryHandler(ready_to_pay, pattern='ready_to_pay'))
    dispatcher.add_handler(CommandHandler("start", start_checking_invoice_status))

    

# Start polling bot watching
    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
    
